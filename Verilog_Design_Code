// Clock Divider Module
module myclk(
    input clk,
    output reg my_clk = 1'b0
);

    reg [25:0] cnt = 0;

    always @(posedge clk) begin
        if (cnt < 30000000) begin 
            cnt = cnt + 1;
        end else begin
            cnt = 0;
            my_clk = ~my_clk;
        end
    end
endmodule


// ============================================================================
// MAIN MODULE
// ============================================================================
module InterruptController (
    input wire clock,                 // Clock
    input wire reset,                 // Reset
    input wire mask,                  // Mask input
    input wire [7:0] intr_rq_1,       // Interrupt request
    inout wire [7:0] data_bus,        // Bidirectional data bus
    input wire acknowledgement,       // Acknowledgement from processor
    output wire interrupt_out,        // Interrupt to processor
    output wire enable                // Bus output enable
);

    // ------------------------------------------------------------------------
    // State Definitions
    // ------------------------------------------------------------------------
    parameter S_Reset              = 4'b0000,
              S_GetCommands        = 4'b0001,
              S_JumpIntMethod      = 4'b0010,
              S_StartPolling       = 4'b0011,
              S_TxIntInfoPolling   = 4'b0100,
              S_AckTxInfoRxPolling = 4'b0101,
              S_AckISRDonePolling  = 4'b0110,
              S_StartPriority      = 4'b0111,
              S_TxIntInfoPriority  = 4'b1000,
              S_AckTxInfoRxPriority= 4'b1001,
              S_AckISRDonePriority = 4'b1010,
              S_Reserved1          = 4'b1011,
              S_Reserved2          = 4'b1100,
              S_Reserved3          = 4'b1101,
              S_Reserved4          = 4'b1110,
              S_Reserved5          = 4'b1111;

    // ------------------------------------------------------------------------
    // Internal Registers
    // ------------------------------------------------------------------------
    reg [3:0] state, next_state;
    reg [1:0] cmd_mode, next_cmd_mode;
    reg [1:0] cmd_cycle, next_cmd_cycle;
    reg [2:0] intr_index, next_intr_index;
    reg [2:0] intr_ptr, next_intr_ptr;

    reg [2:0] prior_table[0:7];
    reg [2:0] prior_table_next[0:7];

    reg oe, next_oe;
    reg [7:0] intr_bus, next_intr_bus;
    reg intr_out, next_intr_out;

    wire clk;
    myclk m1(clock, clk);

    integer i;

    // Masking Logic
    wire [7:0] intr_rq;
    interrupt_masking mask_unit(clk, mask, intr_rq_1, intr_rq);


    // =========================================================================
    // SEQUENTIAL PART - STATE UPDATE
    // =========================================================================
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state       <= S_Reset;
            cmd_mode    <= 2'b00;
            cmd_cycle   <= 2'b00;
            oe          <= 1'b0;
            intr_bus    <= 8'bzzzzzzzz;
            intr_out    <= 1'b0;
            intr_index  <= 3'b000;
            intr_ptr    <= 3'b000;

            for (i = 0; i < 8; i = i + 1) begin
                prior_table[i] <= 3'b000;
            end
        end else begin
            state       <= next_state;
            cmd_mode    <= next_cmd_mode;
            cmd_cycle   <= next_cmd_cycle;
            oe          <= next_oe;
            intr_bus    <= next_intr_bus;
            intr_out    <= next_intr_out;
            intr_index  <= next_intr_index;
            intr_ptr    <= next_intr_ptr;

            for (i = 0; i < 8; i = i + 1) begin
                prior_table[i] <= prior_table_next[i];
            end
        end
    end


    // =========================================================================
    // COMBINATIONAL LOGIC FOR NEXT STATE
    // =========================================================================
    always @* begin
        next_state       = state;
        next_cmd_mode    = cmd_mode;
        next_cmd_cycle   = cmd_cycle;
        next_oe          = oe;
        next_intr_out    = intr_out;
        next_intr_bus    = intr_bus;
        next_intr_index  = intr_index;
        next_intr_ptr    = intr_ptr;

        for (i = 0; i < 8; i = i + 1)
            prior_table_next[i] = prior_table[i];

        case (state)

            // ------------------------------------------------------------
            // RESET STATE
            // ------------------------------------------------------------
            S_Reset: begin
                next_cmd_mode  = 2'b00;
                next_cmd_cycle = 2'b00;
                next_intr_index= 3'b000;
                next_intr_ptr  = 3'b000;

                for (i = 0; i < 8; i = i + 1)
                    prior_table_next[i] = 3'b000;

                next_oe = 1'b0;
                next_state = S_GetCommands;
            end


            // ------------------------------------------------------------
            // GET COMMANDS
            // ------------------------------------------------------------
            S_GetCommands: begin
                next_oe = 1'b0;

                case (data_bus[1:0])
                    2'b01: begin
                        next_cmd_mode = 2'b01;
                        next_state = S_JumpIntMethod;
                    end

                    2'b10: begin
                        case(cmd_cycle)
                            2'b00: begin
                                prior_table_next[0] = data_bus[7:5];
                                prior_table_next[1] = data_bus[4:2];
                                next_cmd_cycle = cmd_cycle + 1'b1;
                            end
                            2'b01: begin
                                prior_table_next[2] = data_bus[7:5];
                                prior_table_next[3] = data_bus[4:2];
                                next_cmd_cycle = cmd_cycle + 1'b1;
                            end
                            2'b10: begin
                                prior_table_next[4] = data_bus[7:5];
                                prior_table_next[5] = data_bus[4:2];
                                next_cmd_cycle = cmd_cycle + 1'b1;
                            end
                            2'b11: begin
                                prior_table_next[6] = data_bus[7:5];
                                prior_table_next[7] = data_bus[4:2];
                                next_cmd_cycle = cmd_cycle + 1'b1;
                                next_cmd_mode  = 2'b10;
                                next_state     = S_JumpIntMethod;
                            end
                        endcase
                    end

                    default: begin
                        next_state = S_GetCommands;
                    end
                endcase
            end


            // ------------------------------------------------------------
            // JUMP TO POLLING OR PRIORITY
            // ------------------------------------------------------------
            S_JumpIntMethod: begin
                next_intr_index = 3'b000;
                next_intr_ptr   = 3'b000;
                next_oe         = 1'b0;

                case (cmd_mode)
                    2'b01: next_state = S_StartPolling;
                    2'b10: next_state = S_StartPriority;
                    default: next_state = S_Reset;
                endcase
            end


            // ------------------------------------------------------------
            // POLLING MODE
            // ------------------------------------------------------------
            S_StartPolling: begin
                if (intr_rq[intr_index]) begin
                    next_intr_out = 1'b1;
                    next_state    = S_TxIntInfoPolling;
                end else begin
                    next_intr_out = 1'b0;
                    next_intr_index = intr_index + 1;
                end
                next_oe = 1'b0;
            end


            S_TxIntInfoPolling: begin
                if (~acknowledgement) begin
                    next_intr_out = 1'b0;
                    next_intr_bus = {5'b01011, intr_index};
                    next_oe = 1'b1;
                    next_state = S_AckTxInfoRxPolling;
                end
            end


            S_AckTxInfoRxPolling: begin
                if (~acknowledgement) begin
                    next_oe = 1'b0;
                    next_state = S_AckISRDonePolling;
                end
            end


            S_AckISRDonePolling: begin
                if (~acknowledgement && (data_bus[7:3] == 5'b10100) &&
                    (data_bus[2:0] == intr_index)) begin
                    next_state = S_StartPolling;
                end else if (~acknowledgement) begin
                    next_state = S_Reset;
                end
            end


            // ------------------------------------------------------------
            // PRIORITY MODE
            // ------------------------------------------------------------
            S_StartPriority: begin
                next_oe = 1'b0;

                if      (intr_rq[prior_table[0]]) begin next_intr_ptr = prior_table[0]; next_intr_out = 1; next_state = S_TxIntInfoPriority; end
                else if (intr_rq[prior_table[1]]) begin next_intr_ptr = prior_table[1]; next_intr_out = 1; next_state = S_TxIntInfoPriority; end
                else if (intr_rq[prior_table[2]]) begin next_intr_ptr = prior_table[2]; next_intr_out = 1; next_state = S_TxIntInfoPriority; end
                else if (intr_rq[prior_table[3]]) begin next_intr_ptr = prior_table[3]; next_intr_out = 1; next_state = S_TxIntInfoPriority; end
                else if (intr_rq[prior_table[4]]) begin next_intr_ptr = prior_table[4]; next_intr_out = 1; next_state = S_TxIntInfoPriority; end
                else if (intr_rq[prior_table[5]]) begin next_intr_ptr = prior_table[5]; next_intr_out = 1; next_state = S_TxIntInfoPriority; end
                else if (intr_rq[prior_table[6]]) begin next_intr_ptr = prior_table[6]; next_intr_out = 1; next_state = S_TxIntInfoPriority; end
                else if (intr_rq[prior_table[7]]) begin next_intr_ptr = prior_table[7]; next_intr_out = 1; next_state = S_TxIntInfoPriority; end
                else next_state = S_StartPriority;
            end


            S_TxIntInfoPriority: begin
                if (~acknowledgement) begin
                    next_intr_out = 1'b0;
                    next_intr_bus = {5'b10011, intr_ptr};
                    next_oe = 1'b1;
                    next_state = S_AckTxInfoRxPriority;
                end
            end


            S_AckTxInfoRxPriority: begin
                if (~acknowledgement) begin
                    next_oe = 1'b0;
                    next_state = S_AckISRDonePriority;
                end
            end


            S_AckISRDonePriority: begin
                if (~acknowledgement && 
                    (data_bus[7:3] == 5'b01100) &&
                    (data_bus[2:0] == intr_ptr)) begin
                    next_state = S_StartPriority;
                end else if (~acknowledgement) begin
                    next_state = S_Reset;
                end
            end


            // ------------------------------------------------------------
            default: begin
                next_state = S_Reset;
                next_oe = 1'b0;
            end

        endcase
    end


    // =========================================================================
    // OUTPUT ASSIGNMENTS
    // =========================================================================
    assign interrupt_out = intr_out;
    assign data_bus      = (oe) ? intr_bus : 8'bzzzzzzzz;
    assign enable        = oe;

endmodule


// ============================================================================
// MASKING MODULE
// ============================================================================
module interrupt_masking (
    input clk,
    input enable,
    input [7:0] interrupt,
    output [7:0] masked_interrupt
);

    reg [7:0] interrupt_mask;

    always @(posedge clk) begin
        if (~enable)
            interrupt_mask <= 8'b11111111;   // No mask
        else
            interrupt_mask <= 8'b00000000;   // Full mask
    end

    assign masked_interrupt = interrupt & interrupt_mask;

endmodule
